{"version":3,"names":[],"mappings":"","sources":["jquery.form.js"],"sourcesContent":[";(function($) {\n\n$.fn.ajaxSubmit = function(options) {\n\t// fast fail if nothing selected (http://dev.jquery.com/ticket/2752)\n\tif (!this.length) {\n\t\tlog('ajaxSubmit: skipping submit process - no element selected');\n\t\treturn this;\n\t}\n\t\n\tvar method, action, url, $form = this;\n\n\tif (typeof options == 'function') {\n\t\toptions = { success: options };\n\t}\n\n\tmethod = this.attr('method');\n\taction = this.attr('action');\n\turl = (typeof action === 'string') ? $.trim(action) : '';\n\turl = url || window.location.href || '';\n\tif (url) {\n\t\t// clean url (don't include hash vaue)\n\t\turl = (url.match(/^([^#]+)/)||[])[1];\n\t}\n\n\toptions = $.extend(true, {\n\t\turl:  url,\n\t\tsuccess: $.ajaxSettings.success,\n\t\ttype: method || 'GET',\n\t\tiframeSrc: /^https/i.test(window.location.href || '') ? 'javascript:false' : 'about:blank'\n\t}, options);\n\n\t// hook for manipulating the form data before it is extracted;\n\t// convenient for use with rich editors like tinyMCE or FCKEditor\n\tvar veto = {};\n\tthis.trigger('form-pre-serialize', [this, options, veto]);\n\tif (veto.veto) {\n\t\tlog('ajaxSubmit: submit vetoed via form-pre-serialize trigger');\n\t\treturn this;\n\t}\n\n\t// provide opportunity to alter form data before it is serialized\n\tif (options.beforeSerialize && options.beforeSerialize(this, options) === false) {\n\t\tlog('ajaxSubmit: submit aborted via beforeSerialize callback');\n\t\treturn this;\n\t}\n\n\tvar traditional = options.traditional;\n\tif ( traditional === undefined ) {\n\t\ttraditional = $.ajaxSettings.traditional;\n\t}\n\t\n\tvar qx,n,v,a = this.formToArray(options.semantic);\n\tif (options.data) {\n\t\toptions.extraData = options.data;\n\t\tqx = $.param(options.data, traditional);\n\t}\n\n\t// give pre-submit callback an opportunity to abort the submit\n\tif (options.beforeSubmit && options.beforeSubmit(a, this, options) === false) {\n\t\tlog('ajaxSubmit: submit aborted via beforeSubmit callback');\n\t\treturn this;\n\t}\n\n\t// fire vetoable 'validate' event\n\tthis.trigger('form-submit-validate', [a, this, options, veto]);\n\tif (veto.veto) {\n\t\tlog('ajaxSubmit: submit vetoed via form-submit-validate trigger');\n\t\treturn this;\n\t}\n\n\tvar q = $.param(a, traditional);\n\tif (qx) {\n\t\tq = ( q ? (q + '&' + qx) : qx );\n\t}\t\n\tif (options.type.toUpperCase() == 'GET') {\n\t\toptions.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;\n\t\toptions.data = null;  // data is null for 'get'\n\t}\n\telse {\n\t\toptions.data = q; // data is the query string for 'post'\n\t}\n\n\tvar callbacks = [];\n\tif (options.resetForm) {\n\t\tcallbacks.push(function() { $form.resetForm(); });\n\t}\n\tif (options.clearForm) {\n\t\tcallbacks.push(function() { $form.clearForm(options.includeHidden); });\n\t}\n\n\t// perform a load on the target only if dataType is not provided\n\tif (!options.dataType && options.target) {\n\t\tvar oldSuccess = options.success || function(){};\n\t\tcallbacks.push(function(data) {\n\t\t\tvar fn = options.replaceTarget ? 'replaceWith' : 'html';\n\t\t\t$(options.target)[fn](data).each(oldSuccess, arguments);\n\t\t});\n\t}\n\telse if (options.success) {\n\t\tcallbacks.push(options.success);\n\t}\n\n\toptions.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg\n\t\tvar context = options.context || options;\t// jQuery 1.4+ supports scope context \n\t\tfor (var i=0, max=callbacks.length; i < max; i++) {\n\t\t\tcallbacks[i].apply(context, [data, status, xhr || $form, $form]);\n\t\t}\n\t};\n\n\t// are there files to upload?\n\tvar fileInputs = $('input:file:enabled[value]', this); // [value] (issue #113)\n\tvar hasFileInputs = fileInputs.length > 0;\n\tvar mp = 'multipart/form-data';\n\tvar multipart = ($form.attr('enctype') == mp || $form.attr('encoding') == mp);\n\n\tvar fileAPI = !!(hasFileInputs && fileInputs.get(0).files && window.FormData);\n\tlog('fileAPI :' + fileAPI);\n\tvar shouldUseFrame = (hasFileInputs || multipart) && !fileAPI;\n\n\t// options.iframe allows user to force iframe mode\n\t// 06-NOV-09: now defaulting to iframe mode if file input is detected\n\tif (options.iframe !== false && (options.iframe || shouldUseFrame)) {\n\t\t// hack to fix Safari hang (thanks to Tim Molendijk for this)\n\t\t// see:  http://groups.google.com/group/jquery-dev/browse_thread/thread/36395b7ab510dd5d\n\t\tif (options.closeKeepAlive) {\n\t\t\t$.get(options.closeKeepAlive, function() {\n\t\t\t\tfileUploadIframe(a);\n\t\t\t});\n\t\t}\n  \t\telse {\n\t\t\tfileUploadIframe(a);\n  \t\t}\n\t}\n\telse if ((hasFileInputs || multipart) && fileAPI) {\n\t\toptions.progress = options.progress || $.noop;\n\t\tfileUploadXhr(a);\n\t}\n\telse {\n\t\t$.ajax(options);\n\t}\n\n\t // fire 'notify' event\n\t this.trigger('form-submit-notify', [this, options]);\n\t return this;\n\n\t // XMLHttpRequest Level 2 file uploads (big hat tip to francois2metz)\n\tfunction fileUploadXhr(a) {\n\t\tvar formdata = new FormData();\n\n\t\tfor (var i=0; i < a.length; i++) {\n\t\t\tif (a[i].type == 'file')\n\t\t\t\tcontinue;\n\t\t\tformdata.append(a[i].name, a[i].value);\n\t\t}\n\n\t\t$form.find('input:file:enabled').each(function(){\n\t\t\tvar name = $(this).attr('name'), files = this.files;\n\t\t\tif (name) {\n\t\t\t\tfor (var i=0; i < files.length; i++)\n\t\t\t\t\tformdata.append(name, files[i]);\n\t\t\t}\n\t\t});\n\n\t\tif (options.extraData) {\n\t\t\tfor (var k in options.extraData)\n\t\t\t\tformdata.append(k, options.extraData[k])\n\t\t}\n\n\t\toptions.data = null;\n\n\t\tvar s = $.extend(true, {}, $.ajaxSettings, options, {\n\t\t\tcontentType: false,\n\t\t\tprocessData: false,\n\t\t\tcache: false,\n\t\t\ttype: 'POST'\n\t\t});\n\n      s.context = s.context || s;\n\n      s.data = null;\n      var beforeSend = s.beforeSend;\n      s.beforeSend = function(xhr, o) {\n          o.data = formdata;\n          if(xhr.upload) { // unfortunately, jQuery doesn't expose this prop (http://bugs.jquery.com/ticket/10190)\n              xhr.upload.onprogress = function(event) {\n                  o.progress(event.position, event.total);\n              };\n          }\n          if(beforeSend)\n              beforeSend.call(o, xhr, options);\n      };\n      $.ajax(s);\n   }\n\n\t// private function for handling file uploads (hat tip to YAHOO!)\n\tfunction fileUploadIframe(a) {\n\t\tvar form = $form[0], el, i, s, g, id, $io, io, xhr, sub, n, timedOut, timeoutHandle;\n\t\tvar useProp = !!$.fn.prop;\n\n\t\tif (a) {\n\t\t\tif ( useProp ) {\n\t\t\t\t// ensure that every serialized input is still enabled\n\t\t\t\tfor (i=0; i < a.length; i++) {\n\t\t\t\t\tel = $(form[a[i].name]);\n\t\t\t\t\tel.prop('disabled', false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i=0; i < a.length; i++) {\n\t\t\t\t\tel = $(form[a[i].name]);\n\t\t\t\t\tel.removeAttr('disabled');\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tif ($(':input[name=submit],:input[id=submit]', form).length) {\n\t\t\t// if there is an input with a name or id of 'submit' then we won't be\n\t\t\t// able to invoke the submit fn on the form (at least not x-browser)\n\t\t\talert('Error: Form elements must not have name or id of \"submit\".');\n\t\t\treturn;\n\t\t}\n\t\t\n\t\ts = $.extend(true, {}, $.ajaxSettings, options);\n\t\ts.context = s.context || s;\n\t\tid = 'jqFormIO' + (new Date().getTime());\n\t\tif (s.iframeTarget) {\n\t\t\t$io = $(s.iframeTarget);\n\t\t\tn = $io.attr('name');\n\t\t\tif (n == null)\n\t\t\t \t$io.attr('name', id);\n\t\t\telse\n\t\t\t\tid = n;\n\t\t}\n\t\telse {\n\t\t\t$io = $('<iframe name=\"' + id + '\" src=\"'+ s.iframeSrc +'\" />');\n\t\t\t$io.css({ position: 'absolute', top: '-1000px', left: '-1000px' });\n\t\t}\n\t\tio = $io[0];\n\n\n\t\txhr = { // mock object\n\t\t\taborted: 0,\n\t\t\tresponseText: null,\n\t\t\tresponseXML: null,\n\t\t\tstatus: 0,\n\t\t\tstatusText: 'n/a',\n\t\t\tgetAllResponseHeaders: function() {},\n\t\t\tgetResponseHeader: function() {},\n\t\t\tsetRequestHeader: function() {},\n\t\t\tabort: function(status) {\n\t\t\t\tvar e = (status === 'timeout' ? 'timeout' : 'aborted');\n\t\t\t\tlog('aborting upload... ' + e);\n\t\t\t\tthis.aborted = 1;\n\t\t\t\t$io.attr('src', s.iframeSrc); // abort op in progress\n\t\t\t\txhr.error = e;\n\t\t\t\ts.error && s.error.call(s.context, xhr, e, status);\n\t\t\t\tg && $.event.trigger('ajaxError', [xhr, s, e]);\n\t\t\t\ts.complete && s.complete.call(s.context, xhr, e);\n\t\t\t}\n\t\t};\n\n\t\tg = s.global;\n\t\t// trigger ajax global events so that activity/block indicators work like normal\n\t\tif (g && ! $.active++) {\n\t\t\t$.event.trigger('ajaxStart');\n\t\t}\n\t\tif (g) {\n\t\t\t$.event.trigger('ajaxSend', [xhr, s]);\n\t\t}\n\n\t\tif (s.beforeSend && s.beforeSend.call(s.context, xhr, s) === false) {\n\t\t\tif (s.global) {\n\t\t\t\t$.active--;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (xhr.aborted) {\n\t\t\treturn;\n\t\t}\n\n\t\t// add submitting element to data if we know it\n\t\tsub = form.clk;\n\t\tif (sub) {\n\t\t\tn = sub.name;\n\t\t\tif (n && !sub.disabled) {\n\t\t\t\ts.extraData = s.extraData || {};\n\t\t\t\ts.extraData[n] = sub.value;\n\t\t\t\tif (sub.type == 'image') {\n\t\t\t\t\ts.extraData[n+'.x'] = form.clk_x;\n\t\t\t\t\ts.extraData[n+'.y'] = form.clk_y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar CLIENT_TIMEOUT_ABORT = 1;\n\t\tvar SERVER_ABORT = 2;\n\n\t\tfunction getDoc(frame) {\n\t\t\tvar doc = frame.contentWindow ? frame.contentWindow.document : frame.contentDocument ? frame.contentDocument : frame.document;\n\t\t\treturn doc;\n\t\t}\n\t\t\n\t\t// Rails CSRF hack (thanks to Yvan Barthelemy)\n\t\tvar csrf_token = $('meta[name=csrf-token]').attr('content');\n\t\tvar csrf_param = $('meta[name=csrf-param]').attr('content');\n\t\tif (csrf_param && csrf_token) {\n\t\t\ts.extraData = s.extraData || {};\n\t\t\ts.extraData[csrf_param] = csrf_token;\n\t\t}\n\n\t\t// take a breath so that pending repaints get some cpu time before the upload starts\n\t\tfunction doSubmit() {\n\t\t\t// make sure form attrs are set\n\t\t\tvar t = $form.attr('target'), a = $form.attr('action');\n\n\t\t\t// update form attrs in IE friendly way\n\t\t\tform.setAttribute('target',id);\n\t\t\tif (!method) {\n\t\t\t\tform.setAttribute('method', 'POST');\n\t\t\t}\n\t\t\tif (a != s.url) {\n\t\t\t\tform.setAttribute('action', s.url);\n\t\t\t}\n\n\t\t\t// ie borks in some cases when setting encoding\n\t\t\tif (! s.skipEncodingOverride && (!method || /post/i.test(method))) {\n\t\t\t\t$form.attr({\n\t\t\t\t\tencoding: 'multipart/form-data',\n\t\t\t\t\tenctype:  'multipart/form-data'\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// support timout\n\t\t\tif (s.timeout) {\n\t\t\t\ttimeoutHandle = setTimeout(function() { timedOut = true; cb(CLIENT_TIMEOUT_ABORT); }, s.timeout);\n\t\t\t}\n\t\t\t\n\t\t\t// look for server aborts\n\t\t\tfunction checkState() {\n\t\t\t\ttry {\n\t\t\t\t\tvar state = getDoc(io).readyState;\n\t\t\t\t\tlog('state = ' + state);\n\t\t\t\t\tif (state.toLowerCase() == 'uninitialized')\n\t\t\t\t\t\tsetTimeout(checkState,50);\n\t\t\t\t}\n\t\t\t\tcatch(e) {\n\t\t\t\t\tlog('Server abort: ' , e, ' (', e.name, ')');\n\t\t\t\t\tcb(SERVER_ABORT);\n\t\t\t\t\ttimeoutHandle && clearTimeout(timeoutHandle);\n\t\t\t\t\ttimeoutHandle = undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add \"extra\" data to form if provided in options\n\t\t\tvar extraInputs = [];\n\t\t\ttry {\n\t\t\t\tif (s.extraData) {\n\t\t\t\t\tfor (var n in s.extraData) {\n\t\t\t\t\t\textraInputs.push(\n\t\t\t\t\t\t\t$('<input type=\"hidden\" name=\"'+n+'\">').attr('value',s.extraData[n])\n\t\t\t\t\t\t\t\t.appendTo(form)[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!s.iframeTarget) {\n\t\t\t\t\t// add iframe to doc and submit the form\n\t\t\t\t\t$io.appendTo('body');\n\t\t\t\t\tio.attachEvent ? io.attachEvent('onload', cb) : io.addEventListener('load', cb, false);\n\t\t\t\t}\n\t\t\t\tsetTimeout(checkState,15);\n\t\t\t\tform.submit();\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\t// reset attrs and remove \"extra\" input elements\n\t\t\t\tform.setAttribute('action',a);\n\t\t\t\tif(t) {\n\t\t\t\t\tform.setAttribute('target', t);\n\t\t\t\t} else {\n\t\t\t\t\t$form.removeAttr('target');\n\t\t\t\t}\n\t\t\t\t$(extraInputs).remove();\n\t\t\t}\n\t\t}\n\n\t\tif (s.forceSync) {\n\t\t\tdoSubmit();\n\t\t}\n\t\telse {\n\t\t\tsetTimeout(doSubmit, 10); // this lets dom updates render\n\t\t}\n\n\t\tvar data, doc, domCheckCount = 50, callbackProcessed;\n\n\t\tfunction cb(e) {\n\t\t\tif (xhr.aborted || callbackProcessed) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tdoc = getDoc(io);\n\t\t\t}\n\t\t\tcatch(ex) {\n\t\t\t\tlog('cannot access response document: ', ex);\n\t\t\t\te = SERVER_ABORT;\n\t\t\t}\n\t\t\tif (e === CLIENT_TIMEOUT_ABORT && xhr) {\n\t\t\t\txhr.abort('timeout');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (e == SERVER_ABORT && xhr) {\n\t\t\t\txhr.abort('server abort');\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!doc || doc.location.href == s.iframeSrc) {\n\t\t\t\t// response not received yet\n\t\t\t\tif (!timedOut)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\tio.detachEvent ? io.detachEvent('onload', cb) : io.removeEventListener('load', cb, false);\n\n\t\t\tvar status = 'success', errMsg;\n\t\t\ttry {\n\t\t\t\tif (timedOut) {\n\t\t\t\t\tthrow 'timeout';\n\t\t\t\t}\n\n\t\t\t\tvar isXml = s.dataType == 'xml' || doc.XMLDocument || $.isXMLDoc(doc);\n\t\t\t\tlog('isXml='+isXml);\n\t\t\t\tif (!isXml && window.opera && (doc.body == null || doc.body.innerHTML == '')) {\n\t\t\t\t\tif (--domCheckCount) {\n\t\t\t\t\t\t// in some browsers (Opera) the iframe DOM is not always traversable when\n\t\t\t\t\t\t// the onload callback fires, so we loop a bit to accommodate\n\t\t\t\t\t\tlog('requeing onLoad callback, DOM not available');\n\t\t\t\t\t\tsetTimeout(cb, 250);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// let this fall through because server response could be an empty document\n\t\t\t\t\t//log('Could not access iframe DOM after mutiple tries.');\n\t\t\t\t\t//throw 'DOMException: not available';\n\t\t\t\t}\n\n\t\t\t\t//log('response detected');\n\t\t\t\tvar docRoot = doc.body ? doc.body : doc.documentElement;\n\t\t\t\txhr.responseText = docRoot ? docRoot.innerHTML : null;\n\t\t\t\txhr.responseXML = doc.XMLDocument ? doc.XMLDocument : doc;\n\t\t\t\tif (isXml)\n\t\t\t\t\ts.dataType = 'xml';\n\t\t\t\txhr.getResponseHeader = function(header){\n\t\t\t\t\tvar headers = {'content-type': s.dataType};\n\t\t\t\t\treturn headers[header];\n\t\t\t\t};\n\t\t\t\t// support for XHR 'status' & 'statusText' emulation :\n\t\t\t\tif (docRoot) {\n\t\t\t\t\txhr.status = Number( docRoot.getAttribute('status') ) || xhr.status;\n\t\t\t\t\txhr.statusText = docRoot.getAttribute('statusText') || xhr.statusText;\n\t\t\t\t}\n\n\t\t\t\tvar dt = (s.dataType || '').toLowerCase();\n\t\t\t\tvar scr = /(json|script|text)/.test(dt);\n\t\t\t\tif (scr || s.textarea) {\n\t\t\t\t\t// see if user embedded response in textarea\n\t\t\t\t\tvar ta = doc.getElementsByTagName('textarea')[0];\n\t\t\t\t\tif (ta) {\n\t\t\t\t\t\txhr.responseText = ta.value;\n\t\t\t\t\t\t// support for XHR 'status' & 'statusText' emulation :\n\t\t\t\t\t\txhr.status = Number( ta.getAttribute('status') ) || xhr.status;\n\t\t\t\t\t\txhr.statusText = ta.getAttribute('statusText') || xhr.statusText;\n\t\t\t\t\t}\n\t\t\t\t\telse if (scr) {\n\t\t\t\t\t\t// account for browsers injecting pre around json response\n\t\t\t\t\t\tvar pre = doc.getElementsByTagName('pre')[0];\n\t\t\t\t\t\tvar b = doc.getElementsByTagName('body')[0];\n\t\t\t\t\t\tif (pre) {\n\t\t\t\t\t\t\txhr.responseText = pre.textContent ? pre.textContent : pre.innerText;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (b) {\n\t\t\t\t\t\t\txhr.responseText = b.textContent ? b.textContent : b.innerText;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (dt == 'xml' && !xhr.responseXML && xhr.responseText != null) {\n\t\t\t\t\txhr.responseXML = toXml(xhr.responseText);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tdata = httpData(xhr, dt, s);\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tstatus = 'parsererror';\n\t\t\t\t\txhr.error = errMsg = (e || status);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t\tlog('error caught: ',e);\n\t\t\t\tstatus = 'error';\n\t\t\t\txhr.error = errMsg = (e || status);\n\t\t\t}\n\n\t\t\tif (xhr.aborted) {\n\t\t\t\tlog('upload aborted');\n\t\t\t\tstatus = null;\n\t\t\t}\n\n\t\t\tif (xhr.status) { // we've set xhr.status\n\t\t\t\tstatus = (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) ? 'success' : 'error';\n\t\t\t}\n\n\t\t\t// ordering of these callbacks/triggers is odd, but that's how $.ajax does it\n\t\t\tif (status === 'success') {\n\t\t\t\ts.success && s.success.call(s.context, data, 'success', xhr);\n\t\t\t\tg && $.event.trigger('ajaxSuccess', [xhr, s]);\n\t\t\t}\n\t\t\telse if (status) {\n\t\t\t\tif (errMsg == undefined)\n\t\t\t\t\terrMsg = xhr.statusText;\n\t\t\t\ts.error && s.error.call(s.context, xhr, status, errMsg);\n\t\t\t\tg && $.event.trigger('ajaxError', [xhr, s, errMsg]);\n\t\t\t}\n\n\t\t\tg && $.event.trigger('ajaxComplete', [xhr, s]);\n\n\t\t\tif (g && ! --$.active) {\n\t\t\t\t$.event.trigger('ajaxStop');\n\t\t\t}\n\n\t\t\ts.complete && s.complete.call(s.context, xhr, status);\n\n\t\t\tcallbackProcessed = true;\n\t\t\tif (s.timeout)\n\t\t\t\tclearTimeout(timeoutHandle);\n\n\t\t\t// clean up\n\t\t\tsetTimeout(function() {\n\t\t\t\tif (!s.iframeTarget)\n\t\t\t\t\t$io.remove();\n\t\t\t\txhr.responseXML = null;\n\t\t\t}, 100);\n\t\t}\n\n\t\tvar toXml = $.parseXML || function(s, doc) { // use parseXML if available (jQuery 1.5+)\n\t\t\tif (window.ActiveXObject) {\n\t\t\t\tdoc = new ActiveXObject('Microsoft.XMLDOM');\n\t\t\t\tdoc.async = 'false';\n\t\t\t\tdoc.loadXML(s);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdoc = (new DOMParser()).parseFromString(s, 'text/xml');\n\t\t\t}\n\t\t\treturn (doc && doc.documentElement && doc.documentElement.nodeName != 'parsererror') ? doc : null;\n\t\t};\n\t\tvar parseJSON = $.parseJSON || function(s) {\n\t\t\treturn window['eval']('(' + s + ')');\n\t\t};\n\n\t\tvar httpData = function( xhr, type, s ) { // mostly lifted from jq1.4.4\n\n\t\t\tvar ct = xhr.getResponseHeader('content-type') || '',\n\t\t\t\txml = type === 'xml' || !type && ct.indexOf('xml') >= 0,\n\t\t\t\tdata = xml ? xhr.responseXML : xhr.responseText;\n\n\t\t\tif (xml && data.documentElement.nodeName === 'parsererror') {\n\t\t\t\t$.error && $.error('parsererror');\n\t\t\t}\n\t\t\tif (s && s.dataFilter) {\n\t\t\t\tdata = s.dataFilter(data, type);\n\t\t\t}\n\t\t\tif (typeof data === 'string') {\n\t\t\t\tif (type === 'json' || !type && ct.indexOf('json') >= 0) {\n\t\t\t\t\tdata = parseJSON(data);\n\t\t\t\t} else if (type === 'script' || !type && ct.indexOf('javascript') >= 0) {\n\t\t\t\t\t$.globalEval(data);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn data;\n\t\t};\n\t}\n};\n\n/**\n * ajaxForm() provides a mechanism for fully automating form submission.\n *\n * The advantages of using this method instead of ajaxSubmit() are:\n *\n * 1: This method will include coordinates for <input type=\"image\" /> elements (if the element\n *\tis used to submit the form).\n * 2. This method will include the submit element's name/value data (for the element that was\n *\tused to submit the form).\n * 3. This method binds the submit() method to the form for you.\n *\n * The options argument for ajaxForm works exactly as it does for ajaxSubmit.  ajaxForm merely\n * passes the options argument along after properly binding events for submit elements and\n * the form itself.\n */\n$.fn.ajaxForm = function(options) {\n\t// in jQuery 1.3+ we can fix mistakes with the ready state\n\tif (this.length === 0) {\n\t\tvar o = { s: this.selector, c: this.context };\n\t\tif (!$.isReady && o.s) {\n\t\t\tlog('DOM not ready, queuing ajaxForm');\n\t\t\t$(function() {\n\t\t\t\t$(o.s,o.c).ajaxForm(options);\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t\t// is your DOM ready?  http://docs.jquery.com/Tutorials:Introducing_$(document).ready()\n\t\tlog('terminating; zero elements found by selector' + ($.isReady ? '' : ' (DOM not ready)'));\n\t\treturn this;\n\t}\n\n\treturn this.ajaxFormUnbind().bind('submit.form-plugin', function(e) {\n\t\tif (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed\n\t\t\te.preventDefault();\n\t\t\t$(this).ajaxSubmit(options);\n\t\t}\n\t}).bind('click.form-plugin', function(e) {\n\t\tvar target = e.target;\n\t\tvar $el = $(target);\n\t\tif (!($el.is(':submit,input:image'))) {\n\t\t\t// is this a child element of the submit el?  (ex: a span within a button)\n\t\t\tvar t = $el.closest(':submit');\n\t\t\tif (t.length == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\ttarget = t[0];\n\t\t}\n\t\tvar form = this;\n\t\tform.clk = target;\n\t\tif (target.type == 'image') {\n\t\t\tif (e.offsetX != undefined) {\n\t\t\t\tform.clk_x = e.offsetX;\n\t\t\t\tform.clk_y = e.offsetY;\n\t\t\t} else if (typeof $.fn.offset == 'function') { // try to use dimensions plugin\n\t\t\t\tvar offset = $el.offset();\n\t\t\t\tform.clk_x = e.pageX - offset.left;\n\t\t\t\tform.clk_y = e.pageY - offset.top;\n\t\t\t} else {\n\t\t\t\tform.clk_x = e.pageX - target.offsetLeft;\n\t\t\t\tform.clk_y = e.pageY - target.offsetTop;\n\t\t\t}\n\t\t}\n\t\t// clear form vars\n\t\tsetTimeout(function() { form.clk = form.clk_x = form.clk_y = null; }, 100);\n\t});\n};\n\n// ajaxFormUnbind unbinds the event handlers that were bound by ajaxForm\n$.fn.ajaxFormUnbind = function() {\n\treturn this.unbind('submit.form-plugin click.form-plugin');\n};\n\n/**\n * formToArray() gathers form element data into an array of objects that can\n * be passed to any of the following ajax functions: $.get, $.post, or load.\n * Each object in the array has both a 'name' and 'value' property.  An example of\n * an array for a simple login form might be:\n *\n * [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ]\n *\n * It is this array that is passed to pre-submit callback functions provided to the\n * ajaxSubmit() and ajaxForm() methods.\n */\n\n$.fn.formToArray = function(semantic) {\n\tvar a = [];\n\tif (this.length === 0) {\n\t\treturn a;\n\t}\n\n\tvar form = this[0];\n\tvar els = semantic ? form.getElementsByTagName('*') : form.elements;\n\tif (!els) {\n\t\treturn a;\n\t}\n\n\tvar i,j,n,v,el,max,jmax;\n\tfor(i=0, max=els.length; i < max; i++) {\n\t\tel = els[i];\n\t\tn = el.name;\n\t\tif (!n) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (semantic && form.clk && el.type == 'image') {\n\t\t\t// handle image inputs on the fly when semantic == true\n\t\t\tif(!el.disabled && form.clk == el) {\n\t\t\t\ta.push({name: n, value: $(el).val(), type: el.type });\n\t\t\t\ta.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tv = $.fieldValue(el, true);\n\t\tif (v && v.constructor == Array) {\n\t\t\tfor(j=0, jmax=v.length; j < jmax; j++) {\n\t\t\t\ta.push({name: n, value: v[j]});\n\t\t\t}\n\t\t}\n\t\telse if (v !== null && typeof v != 'undefined') {\n\t\t\ta.push({name: n, value: v, type: el.type});\n\t\t}\n\t}\n\n\tif (!semantic && form.clk) {\n\t\t// input type=='image' are not found in elements array! handle it here\n\t\tvar $input = $(form.clk), input = $input[0];\n\t\tn = input.name;\n\t\tif (n && !input.disabled && input.type == 'image') {\n\t\t\ta.push({name: n, value: $input.val()});\n\t\t\ta.push({name: n+'.x', value: form.clk_x}, {name: n+'.y', value: form.clk_y});\n\t\t}\n\t}\n\treturn a;\n};\n\n/**\n * Serializes form data into a 'submittable' string. This method will return a string\n * in the format: name1=value1&amp;name2=value2\n */\n$.fn.formSerialize = function(semantic) {\n\t//hand off to jQuery.param for proper encoding\n\treturn $.param(this.formToArray(semantic));\n};\n\n/**\n * Serializes all field elements in the jQuery object into a query string.\n * This method will return a string in the format: name1=value1&amp;name2=value2\n */\n$.fn.fieldSerialize = function(successful) {\n\tvar a = [];\n\tthis.each(function() {\n\t\tvar n = this.name;\n\t\tif (!n) {\n\t\t\treturn;\n\t\t}\n\t\tvar v = $.fieldValue(this, successful);\n\t\tif (v && v.constructor == Array) {\n\t\t\tfor (var i=0,max=v.length; i < max; i++) {\n\t\t\t\ta.push({name: n, value: v[i]});\n\t\t\t}\n\t\t}\n\t\telse if (v !== null && typeof v != 'undefined') {\n\t\t\ta.push({name: this.name, value: v});\n\t\t}\n\t});\n\t//hand off to jQuery.param for proper encoding\n\treturn $.param(a);\n};\n\n$.fn.fieldValue = function(successful) {\n\tfor (var val=[], i=0, max=this.length; i < max; i++) {\n\t\tvar el = this[i];\n\t\tvar v = $.fieldValue(el, successful);\n\t\tif (v === null || typeof v == 'undefined' || (v.constructor == Array && !v.length)) {\n\t\t\tcontinue;\n\t\t}\n\t\tv.constructor == Array ? $.merge(val, v) : val.push(v);\n\t}\n\treturn val;\n};\n\n/**\n * Returns the value of the field element.\n */\n\n$.fieldValue = function(el, successful) {\n\tvar n = el.name, t = el.type, tag = el.tagName.toLowerCase();\n\tif (successful === undefined) {\n\t\tsuccessful = true;\n\t}\n\n\tif (successful && (!n || el.disabled || t == 'reset' || t == 'button' ||\n\t\t(t == 'checkbox' || t == 'radio') && !el.checked ||\n\t\t(t == 'submit' || t == 'image') && el.form && el.form.clk != el ||\n\t\ttag == 'select' && el.selectedIndex == -1)) {\n\t\t\treturn null;\n\t}\n\n\tif (tag == 'select') {\n\t\tvar index = el.selectedIndex;\n\t\tif (index < 0) {\n\t\t\treturn null;\n\t\t}\n\t\tvar a = [], ops = el.options;\n\t\tvar one = (t == 'select-one');\n\t\tvar max = (one ? index+1 : ops.length);\n\t\tfor(var i=(one ? index : 0); i < max; i++) {\n\t\t\tvar op = ops[i];\n\t\t\tif (op.selected) {\n\t\t\t\tvar v = op.value;\n\t\t\t\tif (!v) { // extra pain for IE...\n\t\t\t\t\tv = (op.attributes && op.attributes['value'] && !(op.attributes['value'].specified)) ? op.text : op.value;\n\t\t\t\t}\n\t\t\t\tif (one) {\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\ta.push(v);\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\treturn $(el).val();\n};\n\n$.fn.clearForm = function(includeHidden) {\n\treturn this.each(function() {\n\t\t$('input,select,textarea', this).clearFields(includeHidden);\n\t});\n};\n\n/**\n * Clears the selected form elements.\n */\n$.fn.clearFields = $.fn.clearInputs = function(includeHidden) {\n\tvar re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week)$/i; // 'hidden' is not in this list\n\treturn this.each(function() {\n\t\tvar t = this.type, tag = this.tagName.toLowerCase();\n\t\tif (re.test(t) || tag == 'textarea' || (includeHidden && /hidden/.test(t)) ) {\n\t\t\tthis.value = '';\n\t\t}\n\t\telse if (t == 'checkbox' || t == 'radio') {\n\t\t\tthis.checked = false;\n\t\t}\n\t\telse if (tag == 'select') {\n\t\t\tthis.selectedIndex = -1;\n\t\t}\n\t});\n};\n\n/**\n * Resets the form data.  Causes all form elements to be reset to their original value.\n */\n$.fn.resetForm = function() {\n\treturn this.each(function() {\n\t\t// guard against an input with the name of 'reset'\n\t\t// note that IE reports the reset function as an 'object'\n\t\tif (typeof this.reset == 'function' || (typeof this.reset == 'object' && !this.reset.nodeType)) {\n\t\t\tthis.reset();\n\t\t}\n\t});\n};\n\n/**\n * Enables or disables any matching elements.\n */\n$.fn.enable = function(b) {\n\tif (b === undefined) {\n\t\tb = true;\n\t}\n\treturn this.each(function() {\n\t\tthis.disabled = !b;\n\t});\n};\n\n/**\n * Checks/unchecks any matching checkboxes or radio buttons and\n * selects/deselects and matching option elements.\n */\n$.fn.selected = function(select) {\n\tif (select === undefined) {\n\t\tselect = true;\n\t}\n\treturn this.each(function() {\n\t\tvar t = this.type;\n\t\tif (t == 'checkbox' || t == 'radio') {\n\t\t\tthis.checked = select;\n\t\t}\n\t\telse if (this.tagName.toLowerCase() == 'option') {\n\t\t\tvar $sel = $(this).parent('select');\n\t\t\tif (select && $sel[0] && $sel[0].type == 'select-one') {\n\t\t\t\t// deselect all other options\n\t\t\t\t$sel.find('option').selected(false);\n\t\t\t}\n\t\t\tthis.selected = select;\n\t\t}\n\t});\n};\n\n// expose debug var\n$.fn.ajaxSubmit.debug = false;\n\n// helper fn for console logging\nfunction log() {\n\tif (!$.fn.ajaxSubmit.debug) \n\t\treturn;\n\tvar msg = '[jquery.form] ' + Array.prototype.join.call(arguments,'');\n\tif (window.console && window.console.log) {\n\t\twindow.console.log(msg);\n\t}\n\telse if (window.opera && window.opera.postError) {\n\t\twindow.opera.postError(msg);\n\t}\n};\n\n})(jQuery);\n"],"file":"jquery.form.js"}