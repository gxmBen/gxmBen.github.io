{"version":3,"names":[],"mappings":"","sources":["jquery.navgoco.js"],"sourcesContent":["(function($) {\n\n\t'use strict';\n\n\t/**\n\t * Plugin Constructor. Every menu must have a unique id which will either\n\t * be the actual id attribute or its index in the page.\n\t *\n\t * @param {Element} el\n\t * @param {Object} options\n\t * @param {Integer} idx\n\t * @returns {Object} Plugin Instance\n\t */\n\tvar Plugin = function(el, options, idx) {\n\t\tthis.el = el;\n\t\tthis.$el = $(el);\n\t\tthis.options = options;\n\t\tthis.uuid = this.$el.attr('id') ? this.$el.attr('id') : idx;\n\t\tthis.state = {};\n\t\tthis.init();\n\t\treturn this;\n\t};\n\n\t/**\n\t * Plugin methods\n\t */\n\tPlugin.prototype = {\n\t\t/**\n\t\t * Load cookie, assign a unique data-index attribute to\n\t\t * all sub-menus and show|hide them according to cookie\n\t\t * or based on the parent open class. Find all parent li > a\n\t\t * links add the carent if it's on and attach the event click\n\t\t * to them.\n\t\t */\n\t\tinit: function() {\n\t\t\tvar self = this;\n\t\t\tself._load();\n\t\t\tself.$el.find('ul').each(function(idx) {\n\t\t\t\tvar sub = $(this);\n\t\t\t\tsub.attr('data-index', idx);\n\t\t\t\tif (self.options.save && self.state.hasOwnProperty(idx)) {\n\t\t\t\t\tsub.parent().addClass(self.options.openClass);\n\t\t\t\t\tsub.show();\n\t\t\t\t} else if (sub.parent().hasClass(self.options.openClass)) {\n\t\t\t\t\tsub.show();\n\t\t\t\t\tself.state[idx] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tsub.hide();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (self.options.caret) {\n\t\t\t\tself.$el.find('li:has(ul) > a').append(self.options.caret);\n\t\t\t}\n\n\t\t\tvar links = self.$el.find('li > a');\n\t\t\tlinks.on('click', function(event) {\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tvar sub = $(this).next();\n\t\t\t\tsub = sub.length > 0 ? sub : false;\n\t\t\t\tself.options.onClickBefore.call(this, event, sub);\n\t\t\t\tif (sub) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tself._toggle(sub, sub.is(':hidden'));\n\t\t\t\t\tself._save();\n\t\t\t\t} else {\n\t\t\t\t\tif (self.options.accordion) {\n\t\t\t\t\t\tvar allowed = self.state = self._parents($(this));\n\t\t\t\t\t\tself.$el.find('ul').filter(':visible').each(function() {\n\t\t\t\t\t\t\tvar sub = $(this),\n\t\t\t\t\t\t\t\tidx = sub.attr('data-index');\n\n\t\t\t\t\t\t\tif (!allowed.hasOwnProperty(idx)) {\n\t\t\t\t\t\t\t\tself._toggle(sub, false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tself._save();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tself.options.onClickAfter.call(this, event, sub);\n\t\t\t});\n\t\t},\n\t\t/**\n\t\t * Accepts a JQuery Element and a boolean flag. If flag is false it removes the `open` css\n\t\t * class from the parent li and slides up the sub-menu. If flag is open it adds the `open`\n\t\t * css class to the parent li and slides down the menu. If accordion mode is on all\n\t\t * sub-menus except the direct parent tree will close. Internally an object with the menus\n\t\t * states is maintained for later save duty.\n\t\t *\n\t\t * @param {Element} sub\n\t\t * @param {Boolean} open\n\t\t */\n\t\t_toggle: function(sub, open) {\n\t\t\tvar self = this,\n\t\t\t\tidx = sub.attr('data-index'),\n\t\t\t\tparent = sub.parent();\n\n\t\t\tself.options.onToggleBefore.call(this, sub, open);\n\t\t\tif (open) {\n\t\t\t\tparent.addClass(self.options.openClass);\n\t\t\t\tsub.slideDown(self.options.slide);\n\t\t\t\tself.state[idx] = 1;\n\n\t\t\t\tif (self.options.accordion) {\n\t\t\t\t\tvar allowed = self.state = self._parents(sub);\n\t\t\t\t\tallowed[idx] = self.state[idx] = 1;\n\n\t\t\t\t\tself.$el.find('ul').filter(':visible').each(function() {\n\t\t\t\t\t\tvar sub = $(this),\n\t\t\t\t\t\t\tidx = sub.attr('data-index');\n\n\t\t\t\t\t\tif (!allowed.hasOwnProperty(idx)) {\n\t\t\t\t\t\t\tself._toggle(sub, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tparent.removeClass(self.options.openClass);\n\t\t\t\tsub.slideUp(self.options.slide);\n\t\t\t\tself.state[idx] = 0;\n\t\t\t}\n\t\t\tself.options.onToggleAfter.call(this, sub, open);\n\t\t},\n\t\t/**\n\t\t * Returns all parents of a sub-menu. When obj is true It returns an object with indexes for\n\t\t * keys and the elements as values, if obj is false the object is filled with the value `1`.\n\t\t *\n\t\t * @since v0.1.2\n\t\t * @param {Element} sub\n\t\t * @param {Boolean} obj\n\t\t * @returns {Object}\n\t\t */\n\t\t_parents: function(sub, obj) {\n\t\t\tvar result = {},\n\t\t\t\tparent = sub.parent(),\n\t\t\t\tparents = parent.parents('ul');\n\n\t\t\tparents.each(function() {\n\t\t\t\tvar par = $(this),\n\t\t\t\t\tidx = par.attr('data-index');\n\n\t\t\t\tif (!idx) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tresult[idx] = obj ? par : 1;\n\t\t\t});\n\t\t\treturn result;\n\t\t},\n\t\t/**\n\t\t * If `save` option is on the internal object that keeps track of the sub-menus states is\n\t\t * saved with a cookie. For size reasons only the open sub-menus indexes are stored.\t\t *\n\t\t */\n\t\t_save: function() {\n\t\t\tif (this.options.save) {\n\t\t\t\tvar save = {};\n\t\t\t\tfor (var key in this.state) {\n\t\t\t\t\tif (this.state[key] === 1) {\n\t\t\t\t\t\tsave[key] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcookie[this.uuid] = this.state = save;\n\t\t\t\t$.cookie(this.options.cookie.name, JSON.stringify(cookie), this.options.cookie);\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * If `save` option is on it reads the cookie data. The cookie contains data for all\n\t\t * navgoco menus so the read happens only once and stored in the global `cookie` var.\n\t\t */\n\t\t_load: function() {\n\t\t\tif (this.options.save) {\n\t\t\t\tif (cookie === null) {\n\t\t\t\t\tvar data = $.cookie(this.options.cookie.name);\n\t\t\t\t\tcookie = (data) ? JSON.parse(data) : {};\n\t\t\t\t}\n\t\t\t\tthis.state = cookie.hasOwnProperty(this.uuid) ? cookie[this.uuid] : {};\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Public method toggle to manually show|hide sub-menus. If no indexes are provided all\n\t\t * items will be toggled. You can pass sub-menus indexes as regular params. eg:\n\t\t * navgoco('toggle', true, 1, 2, 3, 4, 5);\n\t\t *\n\t\t * Since v0.1.2 it will also open parents when providing sub-menu indexes.\n\t\t *\n\t\t * @param {Boolean} open\n\t\t */\n\t\ttoggle: function(open) {\n\t\t\tvar self = this,\n\t\t\t\tlength = arguments.length;\n\n\t\t\tif (length <= 1) {\n\t\t\t\tself.$el.find('ul').each(function() {\n\t\t\t\t\tvar sub = $(this);\n\t\t\t\t\tself._toggle(sub, open);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tvar idx,\n\t\t\t\t\tlist = {},\n\t\t\t\t\targs = Array.prototype.slice.call(arguments, 1);\n\t\t\t\tlength--;\n\n\t\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\t\tidx = args[i];\n\t\t\t\t\tvar sub = self.$el.find('ul[data-index=\"' + idx + '\"]').first();\n\t\t\t\t\tif (sub) {\n\t\t\t\t\t\tlist[idx] = sub;\n\t\t\t\t\t\tif (open) {\n\t\t\t\t\t\t\tvar parents = self._parents(sub, true);\n\t\t\t\t\t\t\tfor (var pIdx in parents) {\n\t\t\t\t\t\t\t\tif (!list.hasOwnProperty(pIdx)) {\n\t\t\t\t\t\t\t\t\tlist[pIdx] = parents[pIdx];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (idx in list) {\n\t\t\t\t\tself._toggle(list[idx], open);\n\t\t\t\t}\n\t\t\t}\n\t\t\tself._save();\n\t\t},\n\t\t/**\n\t\t * Removes instance from JQuery data cache and unbinds events.\n\t\t */\n\t\tdestroy: function() {\n\t\t\t$.removeData(this.$el);\n\t\t\tthis.$el.find('li:has(ul) > a').unbind('click');\n\t\t}\n\t};\n\n\t/**\n\t * A JQuery plugin wrapper for navgoco. It prevents from multiple instances and also handles\n\t * public methods calls. If we attempt to call a public method on an element that doesn't have\n\t * a navgoco instance, one will be created for it with the default options.\n\t *\n\t * @param {Object|String} options\n\t */\n\t$.fn.navgoco = function(options) {\n\t\tif (typeof options === 'string' && options.charAt(0) !== '_' && options !== 'init') {\n\t\t\tvar callback = true,\n\t\t\t\targs = Array.prototype.slice.call(arguments, 1);\n\t\t} else {\n\t\t\toptions = $.extend({}, $.fn.navgoco.defaults, options || {});\n\t\t\tif (!$.cookie) {\n\t\t\t\toptions.save = false;\n\t\t\t}\n\t\t}\n\t\treturn this.each(function(idx) {\n\t\t\tvar $this = $(this),\n\t\t\t\tobj = $this.data('navgoco');\n\n\t\t\tif (!obj) {\n\t\t\t\tobj = new Plugin(this, callback ? $.fn.navgoco.defaults : options, idx);\n\t\t\t\t$this.data('navgoco', obj);\n\t\t\t}\n\t\t\tif (callback) {\n\t\t\t\tobj[options].apply(obj, args);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Global var holding all navgoco menus open states\n\t *\n\t * @type {Object}\n\t */\n\tvar cookie = null;\n\n\t/**\n\t * Default navgoco options\n\t *\n\t * @type {Object}\n\t */\n\t$.fn.navgoco.defaults = {\n\t\tcaret: '<span class=\"caret\"></span>',\n\t\taccordion: false,\n\t\topenClass: 'open',\n\t\tsave: true,\n\t\tcookie: {\n\t\t\tname: 'navgoco',\n\t\t\texpires: false,\n\t\t\tpath: '/'\n\t\t},\n\t\tslide: {\n\t\t\tduration: 400,\n\t\t\teasing: 'swing'\n\t\t},\n\t\tonClickBefore: $.noop,\n\t\tonClickAfter: $.noop,\n\t\tonToggleBefore: $.noop,\n\t\tonToggleAfter: $.noop\n\t};\n})(jQuery);"],"file":"jquery.navgoco.js"}